def_class(class_name, fields, methods, actions, enabled, guard, size, XYZ, init)::=<<
align 4
segment .data
segment .bss
segment .text
extern  switch_to_sched
extern  runqput
extern  malloc

; global methods declare
global <class_name>_init
; global <class_name>_methods
<methods: declare_method(); separator="\n">
; global methods declare

<class_name>_init:
<class_name>_init_realloc:
<if(enabled)>
    PUSH DWORD 32768
    CALL malloc
    ADD  ESP, 4
    CMP  DWORD EAX, 0
    JE   <class_name>_init_realloc
    <fields : { a | MOV  DWORD [EAX + 32768 - 4 - <i0>*4], 0    ; <a.name> }; separator="\n">
    MOV  DWORD [EAX + 32768 - <XYZ> + 12], 0    ; next
    MOV  DWORD [EAX + 32768 - <XYZ> + 8], 1     ; lock
    LEA  ECX,  [EAX + 32768 - <XYZ> - 4]
    MOV  DWORD [EAX + 32768 - <XYZ> + 4], ECX   ; Pre ESP
    LEA  ECX,  [EAX + 32768 - <XYZ>]
    MOV  DWORD [EAX + 32768 - <XYZ>], ECX       ; Pre EBP
    LEA  ECX,  [<class_name>_doactions]
    MOV  DWORD [EAX + 32768 - <XYZ> - 4], ECX   ; <class_name>_doactions
    ADD  DWORD EAX, 32768 - <XYZ>
<if(guard)>
    PUSH DWORD EBP
    PUSH DWORD EAX
    CALL runqput
    POP  DWORD EAX
    POP  DWORD EBP
<endif>
<else>
    PUSH DWORD <size>
    CALL malloc
    ADD  ESP, 4
    CMP  DWORD EAX, 0
    JE   <class_name>_init_realloc
<endif>
    ; init code goes here
    ; 
    ; init code ends here
    MOV  DWORD [EAX + 8], 0              		; unlock
    RET

<class_name>_doactions:
<class_name>_doactions_start:
    PUSH DWORD EBP
    ; CALL <class_name>_action
    <actions: {a | CALL <class_name>_action<i>}; separator="\n">
    POP  EBP
    CALL switch_to_sched
    JMP  <class_name>_doactions_start
    RET  ; never be here
    
>>

init_fields(a)::=<<
	MOV  DWORD [EAX + 32768 - <XYZ> + 12 + i*4], 0  ; field_k
>>

declare_method(method_name)::=<<
global <class_name>_<method_name>
>>

def_method(class_name, method_name, num, rettype, args, guard, block) ::=<<
;define method
<class_name>_<method_name>:
<class_name>_<method_name>_start:
    MOV  DWORD ECX, [ESP + 4 + 4*<num>]   ; + 4 * num(args)
<class_name>_<method_name>_checklock:
    MOV  DWORD EAX, 1           ;lock
    XCHG EAX, [ECX + 8]
    CMP  DWORD EAX, 0
    JNE  <class_name>_<method_name>_suspend
<class_name>_<method_name>_checkguard:
    ; method guard starts here
    ; <guard>
    ; method guard ends here
<class_name>_<method_name>_checkguard_fail:
    MOV  DWORD [ECX + 8], 0     ; unlock
<class_name>_<method_name>_suspend:
    PUSH DWORD EBP
    CALL runqput
    POP  EBP
    CALL switch_to_sched
    JMP  <class_name>_<method_name>_start
<class_name>_<method_name>_succeed:
    ; method body starts here
    ; <block>
    ; method body ends here
<class_name>_<method_name>_unlock:
    MOV  DWORD ECX, [ESP + 4 + 4*<num>]   ; + 4 * num(args)
    PUSH DWORD EAX              ; for the return val
    PUSH DWORD EBP
    PUSH DWORD ECX
    CALL runqput
    POP  DWORD ECX
    POP  DWORD EBP
    POP  DWORD EAX              ; for the return val
    ; unlock
    MOV DWORD [ECX + 8], 0
<class_name>_<method_name>_ret:
    RET 
>>

def_action(class_name, action_name, index, guard, block)::=<<
; define action
; <class_name>: <action_name> 
<class_name>_action<index>:
<class_name>_action<index>_start:
    MOV  DWORD ECX, [ESP + 4]
    ; action guard start
    ; 
    ; action guard end

    JE   <class_name>_action<index>_guardfail
    ; action body start
    ; 
    ; action body end
<class_name>_action<index>_guardfail:
    RET
>>
