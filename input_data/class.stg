class(class_name, fields, methods, actions, active, size, XYZ, init)::=<<

align 4
segment .data
segment .bss
segment .text
extern  switch_to_sched
extern  runqput
extern  malloc

; global methods declare
; global <class_name>_methods
<methods: {a | global <class_name>_<a.name> }; separator="\n">
; global methods declare

<class_name>_init:
<class_name>_init_realloc:
    PUSH DWORD <size>
    CALL malloc
    ADD  ESP, 4
    CMP  DWORD EAX, 0
    JE   <class_name>_init_realloc
    <fields : { a | MOV  DWORD [EAX + <size> - <i>*4], 0    ; <a.name> }; separator="\n">
    MOV  DWORD [EAX + <size> - <XYZ> + 12], 0    ; next
    MOV  DWORD [EAX + <size> - <XYZ> + 8], 0     ; lock
    LEA  ECX,  [EAX + <size> - <XYZ> - 4]
    MOV  DWORD [EAX + <size> - <XYZ> + 4], ECX   ; Pre ESP
    LEA  ECX,  [EAX + <size> - <XYZ>]
    MOV  DWORD [EAX + <size> - <XYZ>], ECX       ; Pre EBP
    LEA  ECX,  [<class_name>_doactions]
    MOV  DWORD [EAX + <size> - <XYZ> - 4], ECX   ; <class_name>_doactions
    ADD  DWORD EAX, <size> - <XYZ>
<if(active)>
    PUSH DWORD EBP
    PUSH DWORD EAX
    CALL runqput
    POP  DWORD EAX
    POP  DWORD EBP
<endif>
    ; init code goes here
    ; 
    ; init code ends here
    RET

<class_name>_doactions:
<class_name>_doactions_start:
    PUSH DWORD EBP
    ; CALL <class_name>_action
    <actions: {a | CALL <class_name>_<a.name>}; separator="\n">
    POP  EBP
    CALL switch_to_sched
    JMP  <class_name>_doactions_start
    RET  ; never be here
>>